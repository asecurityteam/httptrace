// Automatically generated by MockGen. DO NOT EDIT!
// Source: github.com/opentracing/opentracing-go (interfaces: Span,SpanContext,Tracer)

package stridetrace

import (
	gomock "github.com/golang/mock/gomock"
	opentracing_go "github.com/opentracing/opentracing-go"
	log "github.com/opentracing/opentracing-go/log"
)

// Mock of Span interface
type mockSpan struct {
	ctrl     *gomock.Controller
	recorder *_mockSpanRecorder
}

// Recorder for mockSpan (not exported)
type _mockSpanRecorder struct {
	mock *mockSpan
}

func newMockSpan(ctrl *gomock.Controller) *mockSpan {
	mock := &mockSpan{ctrl: ctrl}
	mock.recorder = &_mockSpanRecorder{mock}
	return mock
}

func (_m *mockSpan) EXPECT() *_mockSpanRecorder {
	return _m.recorder
}

func (_m *mockSpan) BaggageItem(_param0 string) string {
	ret := _m.ctrl.Call(_m, "BaggageItem", _param0)
	ret0, _ := ret[0].(string)
	return ret0
}

func (_mr *_mockSpanRecorder) BaggageItem(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "BaggageItem", arg0)
}

func (_m *mockSpan) Context() opentracing_go.SpanContext {
	ret := _m.ctrl.Call(_m, "Context")
	ret0, _ := ret[0].(opentracing_go.SpanContext)
	return ret0
}

func (_mr *_mockSpanRecorder) Context() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Context")
}

func (_m *mockSpan) Finish() {
	_m.ctrl.Call(_m, "Finish")
}

func (_mr *_mockSpanRecorder) Finish() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Finish")
}

func (_m *mockSpan) FinishWithOptions(_param0 opentracing_go.FinishOptions) {
	_m.ctrl.Call(_m, "FinishWithOptions", _param0)
}

func (_mr *_mockSpanRecorder) FinishWithOptions(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "FinishWithOptions", arg0)
}

func (_m *mockSpan) Log(_param0 opentracing_go.LogData) {
	_m.ctrl.Call(_m, "Log", _param0)
}

func (_mr *_mockSpanRecorder) Log(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Log", arg0)
}

func (_m *mockSpan) LogEvent(_param0 string) {
	_m.ctrl.Call(_m, "LogEvent", _param0)
}

func (_mr *_mockSpanRecorder) LogEvent(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "LogEvent", arg0)
}

func (_m *mockSpan) LogEventWithPayload(_param0 string, _param1 interface{}) {
	_m.ctrl.Call(_m, "LogEventWithPayload", _param0, _param1)
}

func (_mr *_mockSpanRecorder) LogEventWithPayload(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "LogEventWithPayload", arg0, arg1)
}

func (_m *mockSpan) LogFields(_param0 ...log.Field) {
	_s := []interface{}{}
	for _, _x := range _param0 {
		_s = append(_s, _x)
	}
	_m.ctrl.Call(_m, "LogFields", _s...)
}

func (_mr *_mockSpanRecorder) LogFields(arg0 ...interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "LogFields", arg0...)
}

func (_m *mockSpan) LogKV(_param0 ...interface{}) {
	_s := []interface{}{}
	for _, _x := range _param0 {
		_s = append(_s, _x)
	}
	_m.ctrl.Call(_m, "LogKV", _s...)
}

func (_mr *_mockSpanRecorder) LogKV(arg0 ...interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "LogKV", arg0...)
}

func (_m *mockSpan) SetBaggageItem(_param0 string, _param1 string) opentracing_go.Span {
	ret := _m.ctrl.Call(_m, "SetBaggageItem", _param0, _param1)
	ret0, _ := ret[0].(opentracing_go.Span)
	return ret0
}

func (_mr *_mockSpanRecorder) SetBaggageItem(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SetBaggageItem", arg0, arg1)
}

func (_m *mockSpan) SetOperationName(_param0 string) opentracing_go.Span {
	ret := _m.ctrl.Call(_m, "SetOperationName", _param0)
	ret0, _ := ret[0].(opentracing_go.Span)
	return ret0
}

func (_mr *_mockSpanRecorder) SetOperationName(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SetOperationName", arg0)
}

func (_m *mockSpan) SetTag(_param0 string, _param1 interface{}) opentracing_go.Span {
	ret := _m.ctrl.Call(_m, "SetTag", _param0, _param1)
	ret0, _ := ret[0].(opentracing_go.Span)
	return ret0
}

func (_mr *_mockSpanRecorder) SetTag(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SetTag", arg0, arg1)
}

func (_m *mockSpan) Tracer() opentracing_go.Tracer {
	ret := _m.ctrl.Call(_m, "Tracer")
	ret0, _ := ret[0].(opentracing_go.Tracer)
	return ret0
}

func (_mr *_mockSpanRecorder) Tracer() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Tracer")
}

// Mock of SpanContext interface
type mockSpanContext struct {
	ctrl     *gomock.Controller
	recorder *_mockSpanContextRecorder
}

// Recorder for mockSpanContext (not exported)
type _mockSpanContextRecorder struct {
	mock *mockSpanContext
}

func newMockSpanContext(ctrl *gomock.Controller) *mockSpanContext {
	mock := &mockSpanContext{ctrl: ctrl}
	mock.recorder = &_mockSpanContextRecorder{mock}
	return mock
}

func (_m *mockSpanContext) EXPECT() *_mockSpanContextRecorder {
	return _m.recorder
}

func (_m *mockSpanContext) ForeachBaggageItem(_param0 func(string, string) bool) {
	_m.ctrl.Call(_m, "ForeachBaggageItem", _param0)
}

func (_mr *_mockSpanContextRecorder) ForeachBaggageItem(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "ForeachBaggageItem", arg0)
}

// Mock of Tracer interface
type mockTracer struct {
	ctrl     *gomock.Controller
	recorder *_mockTracerRecorder
}

// Recorder for mockTracer (not exported)
type _mockTracerRecorder struct {
	mock *mockTracer
}

func newMockTracer(ctrl *gomock.Controller) *mockTracer {
	mock := &mockTracer{ctrl: ctrl}
	mock.recorder = &_mockTracerRecorder{mock}
	return mock
}

func (_m *mockTracer) EXPECT() *_mockTracerRecorder {
	return _m.recorder
}

func (_m *mockTracer) Extract(_param0 interface{}, _param1 interface{}) (opentracing_go.SpanContext, error) {
	ret := _m.ctrl.Call(_m, "Extract", _param0, _param1)
	ret0, _ := ret[0].(opentracing_go.SpanContext)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_mockTracerRecorder) Extract(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Extract", arg0, arg1)
}

func (_m *mockTracer) Inject(_param0 opentracing_go.SpanContext, _param1 interface{}, _param2 interface{}) error {
	ret := _m.ctrl.Call(_m, "Inject", _param0, _param1, _param2)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_mockTracerRecorder) Inject(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Inject", arg0, arg1, arg2)
}

func (_m *mockTracer) StartSpan(_param0 string, _param1 ...opentracing_go.StartSpanOption) opentracing_go.Span {
	_s := []interface{}{_param0}
	for _, _x := range _param1 {
		_s = append(_s, _x)
	}
	ret := _m.ctrl.Call(_m, "StartSpan", _s...)
	ret0, _ := ret[0].(opentracing_go.Span)
	return ret0
}

func (_mr *_mockTracerRecorder) StartSpan(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	_s := append([]interface{}{arg0}, arg1...)
	return _mr.mock.ctrl.RecordCall(_mr.mock, "StartSpan", _s...)
}
